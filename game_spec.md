## テトリスゲーム (Rust CLI) - 開発仕様書

### 1. プロジェクト概要

Rust言語と`crossterm`ライブラリを使用して開発された、ターミナル上で動作するテトリスゲーム。標準的なテトリスの要素に加え、独自のブロック消去ルール、スコア計算、および重力システムを特徴とする。

### 2. コアゲームメカニクス

*   **盤面サイズ:** 幅10マス x 高さ20マス。
*   **テトリミノ:** 標準的な7種類のテトリミノ（I, O, T, L, J, S, Z）を使用。
*   **基本操作:**
    *   左右移動 (`←`, `→` キー)
    *   ソフトドロップ (`↓` キー)
    *   ハードドロップ (`↑` キー)
    *   回転 (`Space` キー)
*   **ゲームオーバー:** ブロックが盤面上部に積み上がるとゲームオーバー。
*   **ゲームサイクル** タイトル画面→ゲームプレイ→ゲームオーバー→タイトル画面。

### 3. 視覚表現とUI

*   **ブロック表現:** 各ブロックは `[]` で表現され、前景色で色付けされる。
*   **テトリミノの色:**
    *   使用色はシアン、マゼンタ、イエロー、グリーンの4色のみ。
    *   各テトリミノは4つのブロックで構成され、出現時にこれら4色がランダムに割り当てられる（1つのテトリミノ内で4つのブロックは異なる色を持つ）。
    *   回転時もブロックの色は固定され、位置に応じて色が入れ替わる。
*   **壁の色:** 盤面の枠線は灰色で表示され、ブロックと区別しやすい。
*   **落下位置予測 (ゴースト):**
    *   現在落下中のテトリミノの最終着地点が `::` の文字で表示される。
    *   ゴーストの色は、その位置に着地するブロックの色と同じ。
*   **ライン消去アニメーション:**
    *   アニメーション中のブロックは、元の色を反転させた色で表示される。
    *   アニメーション速度は1ステップあたり120ミリ秒。
*   **UI表示:**
    *   スコア、コンボ数が盤面右側に表示される。
    *   操作説明が表示される。

### 4.  (カスタム)

*   **ライン消去後の演出と得点計算:** ラインが揃ったとき、以下のような演出が行われる
    1. ラインのブロックが点滅する
    2. ラインが最下段の場合ブロックが消えてその上のブロックが1段下がる
    3. 最下段でない場合
        1. ラインよりも下にあるブロックを調べる
        2. 上下左右に同じ色がないブロックが消える（無得点）
        3. 残りのブロックについて、同じ色のブロックが何個つながっているか数えてブロックごとに記憶する
        4. ラインのブロックが灰色になる
        5. 残っているブロックを1段ずつ消しながらラインの灰色ブロックが下がっていくアニメーション
        6. 消されるブロックの数ぶんスコアが加算される。スコアは3で数えた数×10pt
        7. 灰色のラインが一番したの段に達したら灰色のままで残り、フィールドの高さが1段減る

### 5. 技術的詳細と実装ノート

*   **言語:** Rust
*   **ターミナル操作ライブラリ:** `crossterm`
*   **入力ハンドリング:**
    *   ノンブロッキング入力。
    *   先行入力を受け付けて移動・回転のタイミングで反映する。
*   **描画:**
    *   `prev_state`と`state`を比較し、差分のみを描画する方式（ちらつき防止）。
    *   アニメーション終了後の画面クリーンアップを明示的に行う。
*   **テスト:**
    *   `#[cfg(test)]`モジュール内にユニットテストを実装。

### 6. 開発の方針

*    TDDのred-green-refactorのサイクルで開発する
*    cargo testでテストを実施する
*    cargo clippyとcargo fmtでコードの品質を担保する
*    TDDの1サイクルが終わるたびにcargo test, cargo clipply, cargo fmtを実行してからgitにコミットする
*    コミット前に`game_spec.md`のTDD計画を更新して、完了したタスクにチェックを入れる
*    改行を含むコミットメッセージはコマンドラインで失敗しやすいので一時ファイル経由で登録する


---

### カスタムルール実装のTDD計画

- [x] **ステップ1: ライン点滅アニメーション**
    - [x] Red: ラインが消去されたときに新しい`LineBlink`アニメーション状態がトリガーされることを確認するテストを記述する。
    - [x] Green: `GameState`に新しい`GameMode::LineBlinking`または同様のアニメーション状態への状態遷移を実装する。
    - [x] Refactor: `draw`関数で実際の点滅アニメーションを実装する。

- [ ] **ステップ2: 最下段ラインの消去**
    - [x] Red: 消去されたラインがボードの最下段（`y == BOARD_HEIGHT - 1`）である場合、そのラインが単純に削除され、上のブロックが落下することを確認するテストを記述する。
    - [x] Green: `lock_piece`ロジックを修正して、この特定のケースを処理するようにする。
    - [ ] Refactor: `lock_piece`関数をクリーンアップする。

- [ ] **ステップ3: 非最下段ライン - 孤立ブロックの消去**
    - [x] Red: ルール3.1と3.2のテストを記述する。非最下段ラインが消去され、その下にいくつかのブロックがあるボード設定を作成する。テストでは、消去されたラインの下にある、同じ色の隣接ブロックがないブロックが消去されることを確認する。
    - [x] Green: これらのブロックを識別して削除する`remove_isolated_blocks(board: &mut Board, cleared_line_y: usize)`関数を実装する。
    - [ ] Refactor: ブロック消去ロジックを最適化する。

- [x] **ステップ4: 非最下段ライン - 連結ブロックのカウント**
    - [x] Red: ルール3.3のテストを記述する。孤立したブロックが削除された後のボード状態で、`count_connected_blocks(board: &Board, cleared_line_y: usize) -> Vec<(Point, u32)>>`関数をテストする。この関数は、同じ色の連結ブロックの各コンポーネントのサイズを返す。
    - [x] Green: 連結コンポーネントのカウントロジック（例：BFSまたはDFSを使用）を実装する。
    - [x] Refactor: カウントアルゴリズムをクリーンアップする。

- [ ] **ステップ5: 非最下段ライン - ラインが灰色に変わる**
    - [x] Red: 非最下段ラインが消去された後、そのラインのブロックが`Cell::Occupied(Color::Grey)`に置き換えられることを確認するテストを記述する。
    - [x] Green: `lock_piece`関数でこの状態変化を実装する。
    - [ ] Refactor: N/A.

- [x] **ステップ6: 非最下段ライン - 「プッシュダウン」アニメーション**
    - [x] **ステップ6a: `PushDown`アニメーション状態の導入**
        - [x] Red: `clear_lines`が非最下段ラインに対して`Animation::PushDown`をトリガーすることを確認するテストを記述する。
        - [x] Green: `Animation` enumに`PushDown`バリアントを追加し、`clear_lines`がそれをトリガーするように修正する。
        - [x] Refactor: N/A
    - [x] **ステップ6b: ステートマシンロジックの実装（描画なし）**
        - [x] Red: アニメーションの1ステップ後に、ボードから行が削除され、灰色のラインが下に移動することを確認する状態変化テストを記述する。
        - [x] Green: メインループに`PushDown`アニメーションハンドラを実装し、時間経過に応じてボードの状態を正しく変更するロジックを実装する。
        - [x] Refactor: アニメーションロジックをクリーンアップする。
    - [x] **ステップ6c: 描画ロジックの実装と検証**
        - [x] Red: (手動テスト) 視覚的にアニメーションが正しく表示されることを確認する。
        - [x] Green: `draw`関数が必要に応じて状態変化を反映していることを確認し、期待通りに動作しない場合は修正する。
        - [x] Refactor: アニメーションの速度定数を調整し、滑らかな表示にする。

- [x] **ステップ7: スコアリング**
    - [x] Red: ルール3.6のテストを記述する。ステップ4でカウントした連結ブロック数に基づき、プッシュダウンアニメーション完了後にスコアが正しく更新されることをテストする。
    - [x] Green: スコアリングロジックを実装する。
    - [ ] Refactor: N/A.

- [ ] **ステップ8: 灰色ラインの定着とフィールドの縮小**
    - [x] **ステップ8a: `Cell::Solid`の導入と基本ロジックの更新**
        - [x] Red: `Cell::Solid`が衝突判定(`is_valid_position`)でブロックとして扱われることを確認するテストを記述する。
        - [x] Green: `Cell` enumに`Solid`バリアントを追加し、`is_valid_position`と`draw`関数を更新して新しいセルタイプを処理するようにする。
        - [ ] Refactor: N/A
    - [x] **ステップ8b: `PushDown`アニメーションの完了ロジック更新**
        - [x] Red: `PushDown`アニメーション完了後、最下段が`Cell::Solid`で埋められることを確認するテストを記述する。
        - [x] Green: `handle_animation`の`PushDown`ハンドラを修正し、アニメーション完了時に最下段を`Cell::Solid`で埋めるようにする。
        - [ ] Refactor: N/A
    - [ ] **ステップ8c: ライン消去ロジックの更新**
        - [ ] Red: `Cell::Solid`の行が存在する場合に、その上の行だけが正しく消去されることを確認するテストを記述する。
        - [ ] Green: `lock_piece`関数内のライン消去判定ロジックを、`Cell::Occupied`のみを対象とし、`Cell::Solid`を無視するように修正する。
        - [ ] Refactor: N/A
