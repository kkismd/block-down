## テトリスゲーム (Rust CLI) - 開発仕様書

### 1. プロジェクト概要

Rust言語と`crossterm`ライブラリを使用して開発された、ターミナル上で動作するテトリスゲーム。標準的なテトリスの要素に加え、独自のブロック消去ルール、スコア計算、および重力システムを特徴とする。

### 2. コアゲームメカニクス

*   **盤面サイズ:** 幅10マス x 高さ20マス。
*   **テトリミノ:** 標準的な7種類のテトリミノ（I, O, T, L, J, S, Z）を使用。
*   **基本操作:**
    *   左右移動 (`←`, `→` キー)
    *   時計回り回転 (`↓` キー)
    *   半時計回り回転 (`↑` キー)
    *   ソフトドロップ (`Space` キー)
    *   ハードドロップ (`Shift` + `↓` キー)
*   **ゲームオーバー:** ブロックが盤面上部に積み上がるとゲームオーバー。
*   **ゲームサイクル** タイトル画面→ゲームプレイ→ゲームオーバー→タイトル画面。

### 3. 視覚表現とUI

*   **ブロック表現:** 各ブロックは `[]` で表現され、前景色で色付けされる。
*   **テトリミノの色:**
    *   使用色はシアン、マゼンタ、イエローの3色のみ。
    *   各テトリミノは4つのブロックで構成され、出現時にこれら3色からランダムに割り当てられる（1つのテトリミノ内で4つのブロックは異なる色を持ち、かつ隣接するブロックは異なる色を持つ）。
    *   ミノが回転しても、ブロックと色の対応関係は変わらない。
*   **壁の色:** 盤面の枠線は灰色で表示され、ブロックと区別しやすい。
*   **落下位置予測 (ゴースト):**
    *   現在落下中のテトリミノの最終着地点が `::` の文字で表示される。
    *   ゴーストの色は、その位置に着地するブロックの色と同じ。
*   **ライン消去アニメーション:**
    *   アニメーション中のブロックは、元の色を反転させた色で表示される。
    *   アニメーション速度は1ステップあたり120ミリ秒。
*   **UI表示:**
    *   得点が盤面右側に表示される。
    *   その下にNEXTミノが表示される

### 4. カスタムルール

*   **ミノの着地時の盤面の変化**
    1. ブロックが着地するたびに固定ブロックがスキャンされ、上下左右に同じ色が隣接している場合はブロックが数字に変化する。
    2. 数字は、そのブロックが同色のブロックと何個連結しているかを表す数
    3. 数字はバックグラウンドがそのブロックの色で文字色は黒

*   **得点システム**
    1. 得点はブロック消去で加算されるSCOREとMAX-CHAINがある。
    2. SCOREもMAX-CHAINもどちらも色別に数値を管理する
        1. SCORE(CYAN), SCORE(MAGENTA), SCORE(YELLOW)
        2. MAX-CHAIN(CYAN), MAX-CHAIN(MAGENTA), MAX-CHAIN(YELLOW)
    3. SCOREはブロックの消去によって加算される整数値で、ライン消去のたびに加算される
    4. MAX-CHAINは同色ブロックの連結数のゲームプレイ中での最大値で、ミノが着地するたびにに更新される
    5. 画面上での表示は下記のようになる。SCOREの1行目は合計値、MAX-CHAINの1行目は最大値を表示する
```
SCORE:    1120
  CYAN:    200
  MAGENTA: 420
  YELLOW:  500

MAX-CHAIN: 5
  CYAN:    2
  MAGENTA: 4
  YELLOW:  5
```

*   **ライン消去後の演出と得点計算:** ラインが揃ったとき、以下のような演出が行われる
    1. 揃ったすべてのラインのブロックが点滅する
    2. 揃ったラインが最下段でない場合
        1. 揃ったラインよりも下にあるブロックを調べる
        2. 上下左右に同じ色がない（つまり数字に変化していない）ブロックが消える（無得点）
    3. 揃ったすべてのラインのブロックが灰色になる
    4. 灰色になったラインは、互いの間隔を保ったまま、残っているブロックを1段ずつ消しながら一番下のSolidラインの上に下がっていくアニメーションを行う
    5. 下がっていくラインはSolidラインに着地すると停止する。複数のラインが間を開けて下がっていくとき、下のラインが停止しても上のラインは下がり続けて間隔が詰まり、最後には下がりきったラインがすべて隣接する。
    6. 灰色のラインが一番したの段に達したらSolidのままで残り、フィールドの高さがそのラインの数だけ減る
    7. 次のラインが落下するときは底辺のSolidラインの上に積み重なり、フィールドがまたSolidラインの数だけ減る
    8. フィールドがどんどん浅くなり、フィールドがすべて埋まったらゲームオーバー


### 5. 技術的詳細と実装ノート

*   **言語:** Rust
*   **ターミナル操作ライブラリ:** `crossterm`
*   **入力ハンドリング:**
    *   ノンブロッキング入力。
    *   先行入力を受け付けて移動・回転のタイミングで反映する。
*   **描画:**
    *   `prev_state`と`state`を比較し、差分のみを描画する方式（ちらつき防止）。
    *   アニメーション終了後の画面クリーンアップを明示的に行う。
*   **テスト:**
    *   `#[cfg(test)]`モジュール内にユニットテストを実装。

### 6. 開発の方針

*    開発時の対話は日本語で行う
*    TDDのred-green-refactorのサイクルで開発する
*    cargo testでテストを実施する
*    cargo clippyとcargo fmtでコードの品質を担保する
*    TDDの1サイクルが終わるたびにcargo check, cargo test, cargo clipply, cargo fmtを実行してからgit add, commitする
*    non tracking fileをgit addする場合は理由を説明する
*    コミット前に`game_spec.md`のTDD計画を更新して、完了したタスクにチェックを入れる
*    改行を含むコミットメッセージはコマンドラインで失敗しやすいので一時ファイル経由で登録する
*    コミットメッセージは日本語で記載する
*    ソースコードを修正したときだけcargoコマンドで検査を行う
*    TDDのRefactorではRed/Greenで追加したテストを削除しない
*    コードを変更しようとする場合は必ず内容を説明する

---

### バグリスト

*    [ ]

---

### 改善点リスト

*   得点システムが現在ScoreとLinesの2つの数値を管理表示しているが、カスタムルールの得点システムを実装したい

---

### TDD計画

#### 得点システムのカスタマイズ

**目標:** カスタムルールに沿った得点システムを実装し、表示する。

**ステップ 1: 新しい得点管理構造体の導入と `GameState` の変更**
*   [x] **Red:**
    *   `GameState` から `score` と `lines_cleared` を削除し、新しい `CustomScore` 構造体を導入する。
    *   `CustomScore` は、`crossterm::style::Color` ごとの `score` と `max_chain` を保持する。
        *   `CustomScore` 構造体は `src/main.rs` に定義する。
        *   `CustomScore` は `HashMap<Color, u32>` で `score` と `max_chain` を保持する。
        *   `CustomScore` の初期化では、シアン、マゼンタ、イエローの3色に対して `score` と `max_chain` を0で初期化する。
    *   `GameState::new()` で `CustomScore` を初期化する。
    *   `GameState::update_score()` を削除する。
    *   `GameState::handle_input()` 内のスコア加算部分を削除する。
    *   これらの変更により、既存のテストが失敗することを確認する。
*   [x] **Green:**
    *   `GameState` と `CustomScore` の定義を修正し、コンパイルエラーを解消する。
    *   `GameState::new()` で `CustomScore` を正しく初期化する。
    *   `GameState::update_score()` を削除する。
    *   `GameState::handle_input()` 内のスコア加算部分を削除する。
    *   既存のテストが再びパスすることを確認する（スコア関連のテストはまだ修正しない）。
*   [x] **Refactor:**
    *   コードの可読性や構造を改善する。
        *   `CustomScore` 構造体と関連する実装を `src/main.rs` から `src/score.rs` に移動し、モジュールとして分離。

**ステップ 2: MAX-CHAINの更新ロジックの実装**

*   [x] **ステップ 2.1: `CustomScore` の初期状態のテスト**
    *   [x] **Red:**
        *   `src/tests/game_state_tests.rs` に `test_max_chain_initial_state` を追加する。
        *   `GameState` を初期化し、`CustomScore` の `max_chain` が各色で0であることをアサートする。
        *   このテストがパスすることを確認する（ステップ1で既に初期化ロジックが実装されているため、このテストはGreenになるはずですが、念のため確認）。
    *   [x] **Green:** (テストがパスすることを確認)
    *   [x] **Refactor:** (必要であればコードの可読性や構造を改善)

*   **ステップ 2.2: 最初のテトリミノ着地時の `max_chain` 更新テスト**
    *   [x] **Red:**
        *   `src/tests/game_state_tests.rs` に `test_max_chain_updates_on_first_lock` を追加する。
        *   **テストヘルパー関数 `setup_game_state_with_fixed_blocks` を導入する。**
            *   **目的:** テストに必要な `GameState` のインスタンスを、特定のブロックが配置された状態で初期化し、返す。
            *   **引数:** `blocks_to_place: &[(Point, Color)]` (盤面に固定するブロックの位置と色のリスト)
            *   **戻り値:** `GameState`
            *   **機能:** 新しい `GameState` インスタンスを作成し、引数で指定された `blocks_to_place` に従って盤面 (`state.board`) にブロックを配置し、設定された `GameState` インスタンスを返す。
        *   このヘルパー関数を使用して `GameState` を初期化し、特定のテトリミノを盤面に配置し、`GameState::lock_piece()` を呼び出す。
        *   `lock_piece` 実行後、盤面上の連結ブロックの数を手動で計算し、`CustomScore` の `max_chain` がその値に更新されていることをアサートする。
        *   このテストが失敗することを確認する。
    *   [x] **Green:**
        *   `GameState::lock_piece()` 内で、`board_logic::count_connected_blocks` を呼び出し、盤面全体を対象として連結数を取得する。
        *   取得した連結数から、色ごとの `max_chain` を更新するロジックを `GameState` または `CustomScore` に追加する。
        *   テストがパスすることを確認する。
    *   [x] **Refactor:**
        *   `CustomScore` に `update_max_chain(&mut self, color: Color, count: u32)` のようなメソッドを追加し、`GameState::lock_piece()` からこれを呼び出すようにリファクタリングする。
        *   `GameState::lock_piece()` 内の `max_chain` 更新ロジックが簡潔で読みやすいことを確認する。

*   **ステップ 2.3: より大きな連結数での `max_chain` 更新テスト**
    *   [x] **Red:**
        *   `src/tests/game_state_tests.rs` に `test_max_chain_updates_on_larger_chain` を追加する。
        *   既存の `max_chain` よりも大きな連結数を持つテトリミノを配置し、`lock_piece()` を呼び出した後、`max_chain` がさらに大きい値に更新されていることをアサートする。
        *   このテストが失敗することを確認する。
    *   **Green:**
        *   `CustomScore` の `update_max_chain` メソッドが、新しい連結数が既存の `max_chain` よりも大きい場合にのみ更新するように修正する。
        *   テストがパスすることを確認する。
    *   **Refactor:** (必要であればコードの可読性や構造を改善)

*   **ステップ 2.4: より小さい連結数での `max_chain` 更新なしテスト**
    *   **Red:**
        *   `src/tests/game_state_tests.rs` に `test_max_chain_not_updated_on_smaller_chain` を追加する。
        *   既存の `max_chain` よりも小さい連結数を持つテトリミノを配置し、`lock_piece()` を呼び出した後、`max_chain` が更新されないことをアサートする。
        *   このテストが失敗することを確認する。
    *   **Green:**
        *   `CustomScore` の `update_max_chain` メソッドが、新しい連結数が既存の `max_chain` よりも小さい場合には `max_chain` を更新しないことを確認する（ステップ2.3のGreenで既に実装されているはず）。
        *   テストがパスすることを確認する。
    *   **Refactor:** (必要であればコードの可読性や構造を改善)

*   **ステップ 2.5: 複数の色での `max_chain` 更新テスト**
    *   **Red:**
        *   `src/tests/game_state_tests.rs` に `test_max_chain_updates_for_multiple_colors` を追加する。
        *   複数の色を持つブロックが着地した際に、それぞれの色について `max_chain` が正しく更新されていることをアサートする。
        *   このテストが失敗することを確認する。
    *   **Green:**
        *   `GameState::lock_piece()` 内で、`board_logic::count_connected_blocks` の結果を適切に処理し、複数の色について `CustomScore` の `max_chain` を更新するロジックを実装する。
        *   テストがパスすることを確認する。
    *   **Refactor:** (必要であればコードの可読性や構造を改善)

**ステップ 3: カスタムスコア計算ロジックの実装**

*   **Red:**
    *   `board_logic::handle_scoring(state: &mut GameState)` を修正し、`state.blocks_to_score` を利用して色別のスコアを加算するロジックを実装する。
    *   `state.board` を参照して `Point` から `Cell` の色を取得し、`CustomScore` の該当する色にスコアを加算する。
    *   このロジックを検証する新しいテストケースを作成し、失敗することを確認する。
*   **Green:**
    *   `board_logic::handle_scoring` を修正し、色別のスコア加算ロジックを実装する。
    *   テストがパスすることを確認する。
*   **Refactor:**
    *   コードの可読性や構造を改善する。

**ステップ 4: `render` モジュールの変更**

*   **Red:**
    *   `src/render.rs` を修正し、現在のスコア表示部分を、新しい `CustomScore` 構造体から情報を取得して表示するロジックに変更する。
    *   カスタムルールの表示形式 (`SCORE` と `MAX-CHAIN` の合計値と色別内訳) に合わせて表示する。
    *   この変更により、表示が正しくないことを確認する（手動テストまたはスナップショットテストがあればそれを利用）。
*   **Green:**
    *   `src/render.rs` を修正し、`CustomScore` の情報を正しく表示するようにする。
    *   表示が正しく行われることを確認する。
*   **Refactor:**
    *   コードの可読性や構造を改善する。
