## テトリスゲーム (Rust CLI) - 開発仕様書

### 1. プロジェクト概要

Rust言語と`crossterm`ライブラリを使用して開発された、ターミナル上で動作するテトリスゲーム。標準的なテトリスの要素に加え、独自のブロック消去ルール、スコア計算、および重力システムを特徴とする。

### 2. コアゲームメカニクス

*   **盤面サイズ:** 幅10マス x 高さ20マス。
*   **テトリミノ:** 標準的な7種類のテトリミノ（I, O, T, L, J, S, Z）を使用。
*   **基本操作:**
    *   左右移動 (`←`, `→` キー)
    *   時計回り回転 (`↓` キー)
    *   半時計回り回転 (`↑` キー)
    *   ソフトドロップ (`Space` キー)
    *   ハードドロップ (`Shift` + `↓` キー)
*   **ゲームオーバー:** ブロックが盤面上部に積み上がるとゲームオーバー。
*   **ゲームサイクル** タイトル画面→ゲームプレイ→ゲームオーバー→タイトル画面。

### 3. 視覚表現とUI

*   **ブロック表現:** 各ブロックは `[]` で表現され、前景色で色付けされる。
*   **テトリミノの色:**
    *   使用色はシアン、マゼンタ、イエローの3色のみ。
    *   各テトリミノは4つのブロックで構成され、出現時にこれら3色からランダムに割り当てられる（1つのテトリミノ内で4つのブロックは異なる色を持ち、かつ隣接するブロックは異なる色を持つ）。
    *   回転時もブロックの色は固定され、位置に応じて色が入れ替わる。
*   **壁の色:** 盤面の枠線は灰色で表示され、ブロックと区別しやすい。
*   **落下位置予測 (ゴースト):**
    *   現在落下中のテトリミノの最終着地点が `::` の文字で表示される。
    *   ゴーストの色は、その位置に着地するブロックの色と同じ。
*   **ライン消去アニメーション:**
    *   アニメーション中のブロックは、元の色を反転させた色で表示される。
    *   アニメーション速度は1ステップあたり120ミリ秒。
*   **UI表示:**
    *   スコア、コンボ数が盤面右側に表示される。
    *   操作説明が表示される。

### 4.  (カスタム)

*   **ミノの着地時の盤面の変化**
    1. ブロックが着地するたびに固定ブロックがスキャンされ、上下左右に同じ色が隣接している場合はブロックが数字に変化する。
    2. 数字は、そのブロックが同色のブロックと何個連結しているかを表す数
    3. 数字はバックグラウンドがそのブロックの色で文字色は黒

*   **ライン消去後の演出と得点計算:** ラインが揃ったとき、以下のような演出が行われる
    1. 揃ったすべてのラインのブロックが点滅する
    2. 揃ったラインが最下段でない場合
        1. 揃ったラインよりも下にあるブロックを調べる
        2. 上下左右に同じ色がない（つまり数字に変化していない）ブロックが消える（無得点）
    3. 揃ったすべてのラインのブロックが灰色になる
    4. 灰色になったラインは、互いの間隔を保ったまま、残っているブロックを1段ずつ消しながら一番下のSolidラインの上に下がっていくアニメーションを行う
    5. 下がっていくラインはSolidラインに着地すると停止する。複数のラインが間を開けて下がっていくとき、下のラインが停止しても上のラインは下がり続けて間隔が詰まり、最後には下がりきったラインがすべて隣接する。
    6. 消される数字ブロックごとにスコアが加算される。スコアはブロックの数字×10pt
    7. 灰色のラインが一番したの段に達したらSolidのままで残り、フィールドの高さがそのラインの数だけ減る
    8. 次のラインが落下するときは底辺のSolidラインの上に積み重なり、フィールドがまたSolidラインの数だけ減る
    9. フィールドがどんどん浅くなり、フィールドがすべて埋まったらゲームオーバー


### 5. 技術的詳細と実装ノート

*   **言語:** Rust
*   **ターミナル操作ライブラリ:** `crossterm`
*   **入力ハンドリング:**
    *   ノンブロッキング入力。
    *   先行入力を受け付けて移動・回転のタイミングで反映する。
*   **描画:**
    *   `prev_state`と`state`を比較し、差分のみを描画する方式（ちらつき防止）。
    *   アニメーション終了後の画面クリーンアップを明示的に行う。
*   **テスト:**
    *   `src/tests/` ディレクトリ内にユニットテストを実装。
    *   `#[cfg(test)]` 属性を使用し、`board_logic_tests.rs`, `game_state_tests.rs`, `rotation_tests.rs` のように機能ごとにモジュールを分けてテストを記述。
    *   `cargo test` コマンドで実行。


### 6. 開発の方針

*    開発時の対話は日本語で行う
*    TDDのred-green-refactorのサイクルで開発する
*    cargo testでテストを実施する
*    cargo clippyとcargo fmtでコードの品質を担保する
*    TDDの1サイクルが終わるたびにcargo check, cargo test, cargo clipply, cargo fmtを実行してからgit add, commitする
*    non tracking fileをgit addする場合は理由を説明する
*    コミット前に`game_spec.md`のTDD計画を更新して、完了したタスクにチェックを入れる
*    改行を含むコミットメッセージはコマンドラインで失敗しやすいので一時ファイル経由で登録する
*    コミットメッセージは日本語で記載する
*    ソースコードを修正したときだけcargoコマンドで検査を行う
*    TDDのRefactorではRed/Greenで追加したテストを削除しない
*    コードを変更しようとする場合は必ず内容を説明する
*    コンパイルエラーが起きたときや、テストが意図せぬ失敗のときは一つ修正するたびにcargo testを実行して解決したか確認する。

---

### バグリスト

*    [ ]

---

### 改善点リスト

*   ミノの回転をスーパーローテーションシステム（SRS）に対応させたい
    *     その際、色がずれないようにテストを厳重にしたい

---

### 全体的なコードベースのリファクタリング計画 - 優先順位付け

**目的:** コードの可読性、保守性、拡張性を向上させ、将来の機能追加や変更を容易にする。安全でシンプルな変更から着手し、リスクを最小限に抑える。

**優先順位:**

**1. `Animation` enum の `count` フィールドのセマンティクス**
    *   **理由:** `Animation::LineBlink` の `count` フィールドの意図を明確にし、コードの可読性を向上させます。構造変更を伴うため、影響範囲は中程度です。
    *   **リファクタリング案:** `Animation::LineBlink` に `is_on: bool` のようなより明確なフィールドを追加し、その変更が影響する箇所（アニメーション処理ロジック）を更新する。
    *   **評価:** 危険性: 中。

**2. `GameState` の `is_valid_position` メソッドの改善**
    *   **理由:** ゲームのコアロジックに深く関わるため、最も慎重な変更が必要です。このメソッドの変更は、ゲームの動作に直接的な影響を与える可能性があります。
    *   **リファクタリング案:** ロジックを整理し、境界チェックと衝突チェックを別々のプライベートヘルパー関数に分割する。
    *   **評価:** 危険性: 中。

---

### TDD計画: ミノの回転をスーパーローテーションシステム（SRS）に対応させる

**目的:** テトリミノの回転をスーパーローテーションシステム（SRS）に準拠させ、より正確で標準的なゲームプレイを実現する。同時に、回転時のブロックの色の整合性を厳密に保証する。

**フェーズ1: Tetromino構造体の更新と回転状態の管理**

1.  **Red (1.1):** `Tetromino`構造体に`rotation_state: u8`フィールドを追加し、`new_random`および`from_shape`で初期化する。`from_shape`が`rotation_state`を引数として受け取るように変更し、`SHAPES`から適切な回転状態のブロック定義を読み込むようにする。
    *   **テスト:** `Tetromino::new_random()`で生成されたテトリミノの`rotation_state`が0であることを確認するテストを追加。`Tetromino::from_shape()`で特定の`rotation_state`を指定してテトリミノが生成され、そのブロック位置が`SHAPES`の対応するエントリと一致することを確認するテストを追加。
2.  **Green (1.2):** 上記の変更を実装し、テストがパスすることを確認する。
3.  **Refactor (1.3):** `Tetromino::SHAPES`の定義がSRSの回転状態と一致しているか確認し、必要であれば修正する。特に、Iミノの回転中心が正しく設定されているか確認する。

**フェーズ2: 回転ロジックの変更と色の整合性 (改訂)**

**フェーズ2-1: `Tetromino::rotated()`/`rotated_counter_clockwise()` の `rotation_state` 更新と `SHAPES` からのブロック位置取得**

1.  **Red (2.1.1):** `Tetromino::rotated()`および`Tetromino::rotated_counter_clockwise()`メソッドを、動的な回転計算から`rotation_state`を更新し、`SHAPES`から新しいブロック位置を取得するように変更する。この際、ブロックの色のマッピングは考慮しない（既存の色をそのまま引き継ぐか、一時的に無視する）。
    *   **テスト:** 各テトリミノ（Oミノを除く）について、初期状態から時計回り・反時計回りに回転させ、4つの回転状態すべてでブロックの相対位置が正しいことを確認するテストを追加。色のテストはまだ行わない。
2.  **Green (2.1.2):** 上記の変更を実装し、テストがパスすることを確認する。
3.  **Refactor (2.1.3):** コードの可読性を向上させる。

**フェーズ2-2: 回転時のブロック色の整合性保証**

**フェーズ2-2.1: 一般的なテトリミノの色のマッピング**
1.  **Red (2.2.1.1):** `Tetromino::rotated()`および`Tetromino::rotated_counter_clockwise()`メソッドにおいて、回転後のブロック位置と元のブロックの色の対応関係を正しく維持するロジックを実装する。この際、Oミノの特殊な色回転はまだ考慮しない。
    *   **テスト:** 各テトリミノ（Oミノを除く）について、初期状態から時計回り・反時計回りに回転させ、4つの回転状態すべてでブロックの相対位置が正しいことを確認するテストに加え、**回転前後で各ブロックの色がずれていないこと**を厳密に検証するテストを追加。
2.  **Green (2.2.1.2):** 上記の変更を実装し、テストがパスすることを確認する。
3.  **Refactor (2.2.1.3):** コードの可読性を向上させる。

**フェーズ2-2.2: Oミノの特殊な色回転の統合**
1.  **Red (2.2.2.1):** `Tetromino::rotated()`および`Tetromino::rotated_counter_clockwise()`メソッドにおいて、Oミノの特殊な色回転ロジックを、新しい`rotation_state`ベースのロジックと統合し、正しく機能するように修正する。
    *   **テスト:** Oミノについて、時計回り・反時計回りに回転させ、4つの回転状態すべてでブロックの相対位置と色が正しく回転していることを厳密に検証するテストを追加。
2.  **Green (2.2.2.2):** 上記の変更を実装し、テストがパスすることを確認する。
3.  **Refactor (2.2.2.3):** コードの可読性を向上させる。

**フェーズ3: SRSウォールキックデータの定義**

1.  **Red:** SRSのウォールキックデータ（JLSZTとIミノ用）を定数として定義する。これは`src/tetromino.rs`内、または新しい`src/srs.rs`モジュールに配置する。
    *   **テスト:** 定義されたウォールキックデータが、SRSの仕様（例: テトリスガイドライン）と一致していることを確認する静的なテスト（例: 特定のインデックスのデータが期待値と一致するか）を追加。
2.  **Green:** ウォールキックデータを実装し、テストがパスすることを確認する。
3.  **Refactor:** ウォールキックデータの構造が、後続のウォールキック適用ロジックで使いやすいように最適化されているか確認する。

**フェーズ4: `GameState::is_valid_position`のリファクタリング**

1.  **Red:** `GameState::is_valid_position`メソッドを、境界チェックとブロック衝突チェックの2つのプライベートヘルパー関数に分割する。
    *   **テスト:** 分割された各ヘルパー関数が、元の`is_valid_position`と同じロジックで正しく機能することを確認するユニットテストを追加。
2.  **Green:** 上記の変更を実装し、テストがパスすることを確認する。
3.  **Refactor:** 分割された関数名が意図を明確に表しているか、コードの可読性が向上したかを確認する。

**フェーズ5: SRSウォールキックロジックの統合**

1.  **Red:** `GameState::handle_input()`内の回転処理を修正し、`Tetromino::rotated()`または`Tetromino::rotated_counter_clockwise()`で生成された`proposed_piece`に対して、SRSウォールキックを適用する新しいヘルパー関数（例: `try_srs_rotation_kick`）を呼び出すようにする。この関数は、ウォールキックデータを使用して有効な位置を見つけるか、回転を拒否する。
    *   **テスト:**
        *   壁際での回転がウォールキックによって正しく成功するシナリオの統合テストを追加。
        *   ウォールキックでも回転が不可能なシナリオで、回転が拒否されることを確認する統合テストを追加。
        *   既存のブロックとの衝突を伴う回転が、ウォールキックによって正しく解決されるシナリオの統合テストを追加。
2.  **Green:** 上記の変更を実装し、テストがパスすることを確認する。
3.  **Refactor:** `try_srs_rotation_kick`関数のロジックが明確で効率的であるか、エラーハンドリングが適切であるかを確認する。

---

### 完了したタスク

*   [ ] TDD計画を`game_spec.md`に追加した。
