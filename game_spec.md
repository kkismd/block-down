## テトリスゲーム (Rust CLI) - 開発仕様書

### 1. プロジェクト概要

Rust言語と`crossterm`ライブラリを使用して開発された、ターミナル上で動作するテトリスゲーム。標準的なテトリスの要素に加え、独自のブロック消去ルール、スコア計算、および重力システムを特徴とする。

### 2. コアゲームメカニクス

*   **盤面サイズ:** 幅10マス x 高さ20マス。
*   **テトリミノ:** 標準的な7種類のテトリミノ（I, O, T, L, J, S, Z）を使用。
*   **基本操作:**
    *   左右移動 (`←`, `→` キー)
    *   時計回り回転 (`↓` キー)
    *   半時計回り回転 (`↑` キー)
    *   ソフトドロップ (`Space` キー)
    *   ハードドロップ (`Shift` + `↓` キー)
*   **ゲームオーバー:** ブロックが盤面上部に積み上がるとゲームオーバー。
*   **ゲームサイクル** タイトル画面→ゲームプレイ→ゲームオーバー→タイトル画面。

### 3. 視覚表現とUI

*   **ブロック表現:** 各ブロックは `[]` で表現され、前景色で色付けされる。
*   **テトリミノの色:**
    *   使用色はシアン、マゼンタ、イエローの3色のみ。
    *   各テトリミノは4つのブロックで構成され、出現時にこれら3色からランダムに割り当てられる（1つのテトリミノ内で4つのブロックは異なる色を持ち、かつ隣接するブロックは異なる色を持つ）。
    *   回転時もブロックの色は固定され、位置に応じて色が入れ替わる。
    *   ブロックが着地するたびに固定ブロックがスキャンされ、上下左右に同じ色が隣接している場合はブロックが'##'で表示される。
*   **壁の色:** 盤面の枠線は灰色で表示され、ブロックと区別しやすい。
*   **落下位置予測 (ゴースト):**
    *   現在落下中のテトリミノの最終着地点が `::` の文字で表示される。
    *   ゴーストの色は、その位置に着地するブロックの色と同じ。
*   **ライン消去アニメーション:**
    *   アニメーション中のブロックは、元の色を反転させた色で表示される。
    *   アニメーション速度は1ステップあたり120ミリ秒。
*   **UI表示:**
    *   スコア、コンボ数が盤面右側に表示される。
    *   操作説明が表示される。

### 4.  (カスタム)

*   **ライン消去後の演出と得点計算:** ラインが揃ったとき、以下のような演出が行われる
    1. 揃ったすべてのラインのブロックが点滅する
    2. 揃ったラインが最下段でない場合
        1. 揃ったラインよりも下にあるブロックを調べる
        2. 上下左右に同じ色がないブロックが消える（無得点）
        3. 残りのブロックについて、同じ色のブロックが何個つながっているか数えてブロックごとに記憶する
    3. 揃ったすべてのラインのブロックが灰色になる
    4. 灰色になったラインは、互いの間隔を保ったまま、残っているブロックを1段ずつ消しながら一番下のSolidラインの上に下がっていくアニメーションを行う
    5. 下がっていくラインはSolidラインに着地すると停止する。複数のラインが間を開けて下がっていくとき、下のラインが停止しても上のラインは下がり続けて間隔が詰まり、最後には下がりきったラインがすべて隣接する。
    5. 消されるブロックの数ぶんスコアが加算される。スコアは3で数えた数×10pt
    6. 灰色のラインが一番したの段に達したらSolidのままで残り、フィールドの高さがそのラインの数だけ減る
    7. 次のラインが落下するときは底辺のSolidラインの上に積み重なり、フィールドがまたSolidラインの数だけ減る
    8. フィールドがどんどん浅くなり、フィールドがすべて埋まったらゲームオーバー
*   揃ったラインのブロックは、隣接色スキャンによる`##`表示の対象外とし、最終的に`Cell::Solid`となる。


### 5. 技術的詳細と実装ノート

*   **言語:** Rust
*   **ターミナル操作ライブラリ:** `crossterm`
*   **入力ハンドリング:**
    *   ノンブロッキング入力。
    *   先行入力を受け付けて移動・回転のタイミングで反映する。
*   **描画:**
    *   `prev_state`と`state`を比較し、差分のみを描画する方式（ちらつき防止）。
    *   アニメーション終了後の画面クリーンアップを明示的に行う。
*   **テスト:**
    *   `#[cfg(test)]`モジュール内にユニットテストを実装。

### 6. 開発の方針

*    開発時の対話は日本語で行う
*    TDDのred-green-refactorのサイクルで開発する
*    cargo testでテストを実施する
*    cargo clippyとcargo fmtでコードの品質を担保する
*    TDDの1サイクルが終わるたびにcargo check, cargo test, cargo clipply, cargo fmtを実行してからgit add, commitする
*    non tracking fileをgit addする場合は理由を説明する
*    コミット前に`game_spec.md`のTDD計画を更新して、完了したタスクにチェックを入れる
*    改行を含むコミットメッセージはコマンドラインで失敗しやすいので一時ファイル経由で登録する
*    コミットメッセージは日本語で記載する
*    ソースコードを修正したときだけcargoコマンドで検査を行う
*    TDDのRefactorではRed/Greenで追加したテストを削除しない
*    コードを変更しようとする場合は必ず内容を説明する

---

### バグリスト

*    [ ]

---

### 改善点リスト

*   Solidなラインが下にアニメーションするとき、下記のような演出を追加したい
    * これから消去する1下のラインのConnectedブロックが、数字に変化する
        * 数字は、Connectedブロックが同色のブロックと何個連結しているかを表す数
        * 数字はバックグラウンドがそのブロックの色で文字色は黒
    * 数字に変化したあとSolidラインが下がってきて消去される
    * 次の下1ラインに含まれるConnectedブロックが数字に変化する
    * Solidラインが1段下に下がって消去される
    * Solidラインが既存のSolidブロックに着地して止まるまで繰り返し
    * このためにはPushDownアニメーションの前にConnectedからNumberに変化するステップを新しく導入する必要がある

---

### 統合実施計画: Connectedブロックの数字表示アニメーションの実装

この計画は、`game_spec.md`の「改善点リスト」にある「Solidなラインが下にアニメーションするとき、Connectedブロックが数字に変化する演出」を実装するためのものです。以前指摘された難しい点への対策を各ステップに組み込みます。

#### フェーズ 0: 事前リファクタリング - `handle_animation` 関数のモジュール化

**目的:** 新しいアニメーション (`ConnectedToNumber`) の導入をより安全かつスムーズに行うため、既存の `handle_animation` 関数をリファクタリングし、各アニメーションの処理を独立した関数に分割します。これにより、アニメーションの複雑性に関する懸念を軽減します。

-   **Red:**
    -   `handle_animation` 関数が、`LineBlink` と `PushDown` の処理を直接行っていることを確認するテストを追加する。このテストは、リファクタリング後に失敗するはず。~~
-   **Green:**
    -   `main.rs` 内に、`handle_line_blink_animation` と `handle_push_down_animation` という新しい関数を作成し、それぞれ `LineBlink` と `PushDown` のアニメーション処理ロジックを移動する。
    -   `handle_animation` 関数は、これらの新しい関数を呼び出すように変更し、アニメーションキューの管理に専念させる。
    -   テストをパスさせる。~~
-   **Refactor:**
    -   新しい関数のシグネチャと内部ロジックを整理し、可読性と保守性を向上させる。
    -   `cargo test` を実行し、すべてのテストがパスすることを確認する。~~

#### フェーズ 1: `Cell::Number`の導入と`GameState`の更新

**目的:** 新しい `Cell` タイプとアニメーションタイプを導入し、`Connected` ブロックから `Number` ブロックへの変換ロジックの基礎を構築します。

-   **Red:**
    -   `cell.rs`に`Cell::Number(u32, Color)`（数字と元の色を保持）を追加する。
    -   `main.rs`の`Animation` enumに`ConnectedToNumber { blocks: Vec<(Point, u32)>, start_time: Duration }`という新しいアニメーションタイプを追加する。
    -   `clear_lines`関数（`main.rs`）内で、`PushDown`アニメーションをトリガーする前に、`non_bottom_lines_cleared`の下にある`Connected`ブロックを`Cell::Number`に変換するロジックを呼び出すテストを追加する。このテストは、`Cell::Number`が存在しないため、または変換ロジックが未実装のため、失敗するはず。
    -   **対策 (既存のテストへの影響):** `Cell::Connected`を期待していた既存のテストが、`Cell::Number`の導入により失敗する可能性があることを認識し、このフェーズのGreenステップで修正することを計画する。
-   **Green:**
    -   `cell.rs`に`Cell::Number(u32, Color)`を追加する。
    -   `main.rs`の`Animation` enumに`ConnectedToNumber { blocks: Vec<(Point, u32)>, start_time: Duration }`を追加する。
    -   `clear_lines`関数内で、`board_logic::count_connected_blocks`の結果を利用して、`ConnectedToNumber`アニメーションを生成し、`state.animation`に追加する。このアニメーションは、`PushDown`アニメーションの前に実行されるようにする。
    -   `handle_animation`関数（`main.rs`）に`ConnectedToNumber`アニメーションの処理ロジックを追加する。このロジックは、アニメーションのステップに応じて`Cell::Connected`を`Cell::Number`に変換する。
    -   **対策 (既存のテストへの影響):** `Cell::Connected`を期待していた既存のテストを、`Cell::Number`に対応するように修正する。`Cell::Connected`の状態が`Cell::Number`に遷移するロジックをテストする新しいテストも追加する。
    -   テストをパスさせる。
-   **Refactor:**
    -   `Cell` enumの定義を整理する。
    -   `Animation` enumの定義を整理する。
    -   `clear_lines`および`handle_animation`内のロジックを、可読性と保守性を高めるためにリファクタリングする。
    -   `cargo test`を実行し、すべてのテストがパスすることを確認する。

#### フェーズ 2: `Cell::Number`のレンダリング

**目的:** 新しく導入した `Cell::Number` をターミナルに正しく表示します。

-   **Red:**
    -   `render.rs`の`draw`関数内で、`Cell::Number`が正しくレンダリングされることを確認するテストを追加する。具体的には、数字がブロックの背景色で、文字色が黒で表示されることをアサートする。このテストは、`Cell::Number`のレンダリングロジックが未実装のため、失敗するはず。
-   **Green:**
    -   **対策 (`Cell::Number`のレンダリングの正確性):** `render.rs` に `draw_number_cell(renderer: &mut R, x: u16, y: u16, value: u32, color: Color)` のような専用のヘルパー関数を作成し、その中で背景色、前景色、数字の描画、色のリセットを一貫して行う。
    -   `render.rs`の`draw`関数内の`match cell`ブロックに`Cell::Number(value, color)`のケースを追加し、上記ヘルパー関数を呼び出すように実装する。
    -   **対策 (`Cell::Number`のレンダリングの正確性):** `MockRenderer` を使用して、`draw_number_cell` 関数が `SetBackgroundColor`, `SetForegroundColor`, `Print`, `ResetColor` を正しい順序と引数で呼び出していることを厳密にテストする。特に、`ResetColor` が常に呼び出されていることを確認するテストを追加する。
    -   テストをパスさせる。
-   **Refactor:**
    -   `draw`関数内のレンダリングロジックを整理し、重複を避ける。
    -   `cargo test`を実行し、すべてのテストがパスすることを確認する。

#### フェーズ 3: アニメーションシーケンスの調整と`PushDown`への統合

**目的:** `ConnectedToNumber` アニメーションと `PushDown` アニメーションの連携を確立し、ゲームの進行と `current_board_height` の更新を正確に管理します。

-   **Red:**
    -   `handle_animation`関数（`main.rs`）内で、`ConnectedToNumber`アニメーションが完了した後に、対応する`PushDown`アニメーションが開始されることを確認するテストを追加する。
    -   `PushDown`アニメーションが進行する際に、その下のラインの`Connected`ブロックが`ConnectedToNumber`アニメーションをトリガーすることを確認するテストを追加する。
    -   このテストは、アニメーションのシーケンスが正しく連携していないため、失敗するはず。
-   **Green:**
    -   **対策 (アニメーションの複雑性):** `handle_animation`内で、`ConnectedToNumber`アニメーションが完了した際に、次の`PushDown`アニメーションをキューに追加するロジックを実装する。この際、アニメーションキューにアニメーションを追加する際に、重複や不必要なトリガーを防ぐためのチェックを強化する。
    -   **対策 (`current_board_height`とアニメーションの連携):** `handle_animation`内で、`PushDown`アニメーションの処理中に、その下のラインに`Connected`ブロックが存在する場合、新しい`ConnectedToNumber`アニメーションを生成してキューに追加するロジックを実装する。この際、アニメーション間の明確な状態同期を確保するメカニズムを導入する。
    -   **対策 (`current_board_height`とアニメーションの連携):** ボードの座標を扱う際に、`current_board_height` を考慮したヘルパー関数（例: `get_absolute_y(relative_y: usize, current_board_height: usize) -> usize`）を導入し、座標計算のミスを防ぐ。
    -   テストをパスさせる。
-   **Refactor:**
    -   アニメーション処理のロジックを整理し、状態遷移が明確になるようにする。
    -   `cargo test`を実行し、すべてのテストがパスすることを確認する。
    -   **対策 (`current_board_height`とアニメーションの連携):** `MockTimeProvider` を使用して、`ConnectedToNumber` アニメーションが完了し、`PushDown` アニメーションが開始され、`current_board_height` が減少する一連のシーケンスをシミュレートする詳細な統合テストを作成する。このテストでは、各ステップでのボードの状態と `current_board_height` の値が期待通りであることを厳密にアサートする。

---

### 統合実施計画の補足事項

*   **開発方針の遵守:** 各フェーズ、各ステップにおいて、`game_spec.md` に記載されている「開発の方針」を厳守します（TDDサイクル、`cargo test`, `clippy`, `fmt` の実行、コミットメッセージなど）。
*   **継続的なテスト:** 新しい機能を追加する際も、既存のテストが常にパスすることを確認しながら進めます。
*   **手動確認:** 各フェーズの完了後、ゲームを実際に実行し、視覚的な動作が期待通りであることを確認します。
