## テトリスゲーム (Rust CLI) - 開発仕様書

### 1. プロジェクト概要

Rust言語と`crossterm`ライブラリを使用して開発された、ターミナル上で動作するテトリスゲーム。標準的なテトリスの要素に加え、独自のブロック消去ルール、スコア計算、および重力システムを特徴とする。

### 2. コアゲームメカニクス

*   **盤面サイズ:** 幅10マス x 高さ20マス。
*   **テトリミノ:** 標準的な7種類のテトリミノ（I, O, T, L, J, S, Z）を使用。
*   **基本操作:**
    *   左右移動 (`←`, `→` キー)
    *   時計回り回転 (`↓` キー)
    *   半時計回り回転 (`↑` キー)
    *   ソフトドロップ (`Space` キー)
    *   ハードドロップ (`Shift` + `↓` キー)
*   **ゲームオーバー:** ブロックが盤面上部に積み上がるとゲームオーバー。
*   **ゲームサイクル** タイトル画面→ゲームプレイ→ゲームオーバー→タイトル画面。

### 3. 視覚表現とUI

*   **ブロック表現:** 各ブロックは `[]` で表現され、前景色で色付けされる。
*   **テトリミノの色:**
    *   使用色はシアン、マゼンタ、イエロー、グリーンの4色のみ。
    *   各テトリミノは4つのブロックで構成され、出現時にこれら4色がランダムに割り当てられる（1つのテトリミノ内で4つのブロックは異なる色を持つ）。
    *   回転時もブロックの色は固定され、位置に応じて色が入れ替わる。
    *   ブロックが着地するたびに固定ブロックがスキャンされ、上下左右に同じ色が隣接している場合はブロックが'##'で表示される。
*   **壁の色:** 盤面の枠線は灰色で表示され、ブロックと区別しやすい。
*   **落下位置予測 (ゴースト):**
    *   現在落下中のテトリミノの最終着地点が `::` の文字で表示される。
    *   ゴーストの色は、その位置に着地するブロックの色と同じ。
*   **ライン消去アニメーション:**
    *   アニメーション中のブロックは、元の色を反転させた色で表示される。
    *   アニメーション速度は1ステップあたり120ミリ秒。
*   **UI表示:**
    *   スコア、コンボ数が盤面右側に表示される。
    *   操作説明が表示される。

### 4.  (カスタム)

*   **ライン消去後の演出と得点計算:** ラインが揃ったとき、以下のような演出が行われる
    1. 揃ったすべてのラインのブロックが点滅する
    2. 揃ったラインが最下段でない場合
        1. 揃ったラインよりも下にあるブロックを調べる
        2. 上下左右に同じ色がないブロックが消える（無得点）
        3. 残りのブロックについて、同じ色のブロックが何個つながっているか数えてブロックごとに記憶する
    3. 揃ったすべてのラインのブロックが灰色になる
    4. 灰色になったラインは、互いの間隔を詰めて、残っているブロックを1段ずつ消しながら一番下のSolidラインの上に下がっていくアニメーション
    5. 消されるブロックの数ぶんスコアが加算される。スコアは3で数えた数×10pt
    6. 灰色のラインが一番したの段に達したらSolidのままで残り、フィールドの高さがそのラインの数だけ減る
    7. 次のラインが落下するときは底辺のSolidラインの上に積み重なり、フィールドがまたSolidラインの数だけ減る
    8. フィールドがどんどん浅くなり、フィールドがすべて埋まったらゲームオーバー
*   揃ったラインのブロックは、隣接色スキャンによる`##`表示の対象外とし、最終的に`Cell::Solid`となる。

### 5. 技術的詳細と実装ノート

*   **言語:** Rust
*   **ターミナル操作ライブラリ:** `crossterm`
*   **入力ハンドリング:**
    *   ノンブロッキング入力。
    *   先行入力を受け付けて移動・回転のタイミングで反映する。
*   **描画:**
    *   `prev_state`と`state`を比較し、差分のみを描画する方式（ちらつき防止）。
    *   アニメーション終了後の画面クリーンアップを明示的に行う。
*   **テスト:**
    *   `#[cfg(test)]`モジュール内にユニットテストを実装。

### 6. 開発の方針

*    TDDのred-green-refactorのサイクルで開発する
*    cargo testでテストを実施する
*    cargo clippyとcargo fmtでコードの品質を担保する
*    TDDの1サイクルが終わるたびにcargo test, cargo clipply, cargo fmtを実行してからgit add, commitする
*    コミット前に`game_spec.md`のTDD計画を更新して、完了したタスクにチェックを入れる
*    改行を含むコミットメッセージはコマンドラインで失敗しやすいので一時ファイル経由で登録する
*    コミットメッセージは日本語で記載する
*    ソースコードを修正したときだけcargoコマンドで検査を行う
*    TDDのRefactorではRed/Greenで追加したテストを削除しない

---

### バグリスト

*   [ ] ラインが揃ったとき、solidブロックも点滅すべき
*   [ ] SミノとOミノが回転するとき色の配置がずれる
*   [ ] Solidブロックの隣に同色のブロックが着地したら同色とみなして落ちたブロックがSolidになってほしい

### 改善点リスト

*    次のミノの決定のランダムロジックを7-bag方式に変更したい
*    新しいミノの色を以下のルールで4色から3色に減らしたい
        「各テトリミノは4つのブロックで構成され、出現時にこれらのうち3色が同じ色が隣り合わないようにランダムに割り当てられる。」

---

### TDD計画

#### バグリスト1: ラインが揃ったとき、solidブロックも点滅すべき

**現在の問題:**
ラインが揃った際に、`Cell::Solid`状態のブロックが点滅アニメーションの対象外となっている可能性がある。

**目標:**
ラインが揃ったとき、`Cell::Solid`状態のブロックも他のブロックと同様に点滅アニメーションの対象となり、正しく反転色で表示され、アニメーション終了後に元の色に戻るようにする。

**TDDステップ:**

1.  **Red (テストの追加):**
    *   **テストケース1: Solidブロックの点滅アニメーションへの組み込み**
        *   **目的:** ラインが揃った際に、`Cell::Solid`状態のブロックが点滅アニメーションの対象に含まれることを確認する。
        *   **手順:**
            1.  テスト用の盤面をセットアップし、ラインが揃う状況を作り出す。この際、揃うラインに`Cell::Solid`状態のブロックが含まれるようにする。
            2.  ライン消去アニメーションが開始されるトリガーを引く。
            3.  アニメーションの最初のフレームで、`Cell::Solid`状態のブロックが反転色で描画されることをアサートする。
            4.  アニメーションの最終フレームで、`Cell::Solid`状態のブロックが元の色で描画されることをアサートする。

    *   **テストケース2: Solidブロックの色の保持**
        *   **目的:** 点滅アニメーション中および終了後も、`Cell::Solid`状態のブロックの元の色情報が正しく保持されていることを確認する。
        *   **手順:**
            1.  テスト用の盤面をセットアップし、ラインが揃う状況を作り出す。この際、揃うラインに`Cell::Solid`状態のブロックが含まれるようにする。
            2.  ライン消去アニメーションが開始されるトリガーを引く。
            3.  アニメーションの各フレームで、`Cell::Solid`状態のブロックの色が、点滅ロジックに従って正しく変化していることをアサートする。
            4.  アニメーション終了後、`Cell::Solid`状態のブロックがアニメーション開始前の元の色に戻っていることをアサートする。

2.  **Green (最小限の実装):**
    *   ライン消去アニメーションを処理するコード（`render.rs`や`main.rs`内の関連ロジック）を特定する。
    *   アニメーション対象のブロックを決定するロジックを確認し、`Cell::Solid`状態のブロックが除外されていないか確認する。
    *   もし除外されている場合、`Cell::Solid`状態のブロックもアニメーション対象に含めるように修正する。
    *   `Cell::Solid`状態のブロックの色情報を一時的に保存し、アニメーション中に反転色を適用し、アニメーション終了後に元の色に戻すメカニズムを実装または修正する。
    *   既存のテストと新しく追加したテストを実行し、すべてのテストがパスすることを確認する。

3.  **Refactor (コードの改善):**
    *   `cargo clippy`と`cargo fmt`を実行し、コードの品質を担保する。
    *   コードの重複を排除し、可読性を向上させる。
    *   必要に応じて、関数やモジュールの分割を検討する。
