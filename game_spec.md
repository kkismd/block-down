## テトリスゲーム (Rust CLI) - 開発仕様書

### 1. プロジェクト概要

Rust言語と`crossterm`ライブラリを使用して開発された、ターミナル上で動作するテトリスゲーム。標準的なテトリスの要素に加え、独自のブロック消去ルール、スコア計算、および重力システムを特徴とする。

### 2. コアゲームメカニクス

*   **盤面サイズ:** 幅10マス x 高さ20マス。
*   **テトリミノ:** 標準的な7種類のテトリミノ（I, O, T, L, J, S, Z）を使用。
*   **基本操作:**
    *   左右移動 (`←`, `→` キー)
    *   時計回り回転 (`↓` キー)
    *   半時計回り回転 (`↑` キー)
    *   ソフトドロップ (`Space` キー)
    *   ハードドロップ (`Shift` + `↓` キー)
*   **ゲームオーバー:** ブロックが盤面上部に積み上がるとゲームオーバー。
*   **ゲームサイクル** タイトル画面→ゲームプレイ→ゲームオーバー→タイトル画面。

### 3. 視覚表現とUI

*   **ブロック表現:** 各ブロックは `[]` で表現され、前景色で色付けされる。
*   **テトリミノの色:**
    *   使用色はシアン、マゼンタ、イエローの3色のみ。
    *   各テトリミノは4つのブロックで構成され、出現時にこれら3色からランダムに割り当てられる（1つのテトリミノ内で4つのブロックは異なる色を持ち、かつ隣接するブロックは異なる色を持つ）。
    *   回転時もブロックの色は固定され、位置に応じて色が入れ替わる。
*   **壁の色:** 盤面の枠線は灰色で表示され、ブロックと区別しやすい。
*   **落下位置予測 (ゴースト):**
    *   現在落下中のテトリミノの最終着地点が `::` の文字で表示される。
    *   ゴーストの色は、その位置に着地するブロックの色と同じ。
*   **ライン消去アニメーション:**
    *   アニメーション中のブロックは、元の色を反転させた色で表示される。
    *   アニメーション速度は1ステップあたり120ミリ秒。
*   **UI表示:**
    *   スコア、コンボ数が盤面右側に表示される。
    *   操作説明が表示される。

### 4.  (カスタム)

*   **ミノの着地時の盤面の変化**
    1. ブロックが着地するたびに固定ブロックがスキャンされ、上下左右に同じ色が隣接している場合はブロックが数字に変化する。
    2. 数字は、そのブロックが同色のブロックと何個連結しているかを表す数
    3. 数字はバックグラウンドがそのブロックの色で文字色は黒

*   **ライン消去後の演出と得点計算:** ラインが揃ったとき、以下のような演出が行われる
    1. 揃ったすべてのラインのブロックが点滅する
    2. 揃ったラインが最下段でない場合
        1. 揃ったラインよりも下にあるブロックを調べる
        2. 上下左右に同じ色がない（つまり数字に変化していない）ブロックが消える（無得点）
    3. 揃ったすべてのラインのブロックが灰色になる
    4. 灰色になったラインは、互いの間隔を保ったまま、残っているブロックを1段ずつ消しながら一番下のSolidラインの上に下がっていくアニメーションを行う
    5. 下がっていくラインはSolidラインに着地すると停止する。複数のラインが間を開けて下がっていくとき、下のラインが停止しても上のラインは下がり続けて間隔が詰まり、最後には下がりきったラインがすべて隣接する。
    6. 消される数字ブロックごとにスコアが加算される。スコアはブロックの数字×10pt
    7. 灰色のラインが一番したの段に達したらSolidのままで残り、フィールドの高さがそのラインの数だけ減る
    8. 次のラインが落下するときは底辺のSolidラインの上に積み重なり、フィールドがまたSolidラインの数だけ減る
    9. フィールドがどんどん浅くなり、フィールドがすべて埋まったらゲームオーバー


### 5. 技術的詳細と実装ノート

*   **言語:** Rust
*   **ターミナル操作ライブラリ:** `crossterm`
*   **入力ハンドリング:**
    *   ノンブロッキング入力。
    *   先行入力を受け付けて移動・回転のタイミングで反映する。
*   **描画:**
    *   `prev_state`と`state`を比較し、差分のみを描画する方式（ちらつき防止）。
    *   アニメーション終了後の画面クリーンアップを明示的に行う。
*   **テスト:**
    *   `#[cfg(test)]`モジュール内にユニットテストを実装。

### 6. 開発の方針

*    開発時の対話は日本語で行う
*    TDDのred-green-refactorのサイクルで開発する
*    cargo testでテストを実施する
*    cargo clippyとcargo fmtでコードの品質を担保する
*    TDDの1サイクルが終わるたびにcargo check, cargo test, cargo clipply, cargo fmtを実行してからgit add, commitする
*    non tracking fileをgit addする場合は理由を説明する
*    コミット前に`game_spec.md`のTDD計画を更新して、完了したタスクにチェックを入れる
*    改行を含むコミットメッセージはコマンドラインで失敗しやすいので一時ファイル経由で登録する
*    コミットメッセージは日本語で記載する
*    ソースコードを修正したときだけcargoコマンドで検査を行う
*    TDDのRefactorではRed/Greenで追加したテストを削除しない
*    コードを変更しようとする場合は必ず内容を説明する

---

### バグリスト

*    [ ]

---

### 改善点リスト

*    現状の実装ではブロックが積まれるとき、フィールドにある同色隣接ブロックがConnectedとなり"##"で表示されるが、連結数を表す数字の反転表示に変更したい。
    *    「ミノの着地時の盤面の変化」というカスタム項目に記載したので参照のこと。

---

### TDD計画: 連結ブロックの数字表示機能 (R-G-Rサイクル)

#### 目的
テトリミノが着地した際、盤面上の同色で連結しているブロックをスキャンし、その連結数を数字として表示する機能を実装する。

#### 前提
`Cell`構造体に必要なフィールド（`connection_count`, `display_color`, `text_color`）が追加されていること。

---

**サイクル 1: `Cell`構造体の更新と`calculate_connected_blocks`関数の基本構造**

1.  **Red (テストの追加)**
    *   **テストケース1:** `Cell`構造体に`connection_count: Option<u8>`, `display_color: Option<Color>`, `text_color: Option<Color>`フィールドが存在し、初期値が`None`であることを確認するテスト。（これはコンパイル時チェックに近いが、テストとして表現する）
    *   **テストケース2:** 空の盤面または単一の固定ブロックがある盤面を`calculate_connected_blocks`関数に渡した場合、パニックせず、`Cell`の`connection_count`が`None`のままであることを確認するテスト。
    *   **テストケース3:** 盤面に固定ブロックが一つだけ存在し、その周囲に同色のブロックがない場合、`calculate_connected_blocks`関数実行後もそのブロックの`connection_count`が`None`のままであることを確認するテスト。
2.  **Green (最小限の実装)**
    *   `Cell`構造体に上記フィールドを追加し、初期値を`None`とする。
    *   `fn calculate_connected_blocks(board: &mut Board)` の関数シグネチャを定義する。
    *   関数内で盤面をイテレートする基本的なループを実装する。
    *   各セルが固定ブロックであるかを確認するロジックを追加する。
3.  **Refactor (コードの改善)**
    *   `Cell`構造体のフィールド名やメソッド名が意図を明確にしているか確認する。
    *   関数名や変数名が意図を明確にしているか確認する。
    *   盤面イテレーションのロジックを整理する。

---

**サイクル 2: 2つの同色ブロックの連結検出とカウント**

1.  **Red (テストの追加)**
    *   **テストケース:** 2つの同色ブロックが隣接して配置された盤面を`calculate_connected_blocks`関数に渡した場合、両方のブロックの`connection_count`が`Some(2)`に設定されていることを確認するテスト。
2.  **Green (最小限の実装)**
    *   `calculate_connected_blocks`関数内に、固定ブロックから隣接する同色ブロックを探索する初期ロジック（例: 4方向チェック）を追加する。
    *   探索で見つかった同色ブロックの数をカウントし、`connection_count`に設定するロジックを実装する（この時点ではまだ完全なBFS/DFSではなく、単純な隣接チェックとカウント）。
3.  **Refactor (コードの改善)**
    *   隣接チェックのロジックをヘルパー関数として抽出することを検討する。
    *   カウントロジックの重複を避ける。

---

**サイクル 3: 複数の同色ブロックの連結検出 (BFS/DFSの導入)**

1.  **Red (テストの追加)**
    *   **テストケース:** 3つの同色ブロックが一直線に隣接して配置された盤面を`calculate_connected_blocks`関数に渡した場合、3つのブロックすべてが`connection_count`が`Some(3)`に設定されていることを確認するテスト。
    *   **テストケース:** 4つの同色ブロックが2x2の形で隣接して配置された盤面を`calculate_connected_blocks`関数に渡した場合、4つのブロックすべてが`connection_count`が`Some(4)`に設定されていることを確認するテスト。
    *   **テストケース:** 連結が途切れている同色ブロックのグループが複数ある盤面を`calculate_connected_blocks`関数に渡した場合、それぞれのグループで正しく連結数が設定されていることを確認するテスト。
    *   **テストケース:** 異なる色のブロックが隣接している場合、数字に変化しないことを確認するテスト。
    *   **テストケース:** 盤面の端にブロックが配置された場合の連結数を正しく計算できることを確認するテスト。
2.  **Green (最小限の実装)**
    *   `calculate_connected_blocks`関数内に、BFSまたはDFSのアルゴリズムを導入し、連結コンポーネント全体を探索し、そのサイズを正確にカウントするロジックを実装する。
    *   探索中に訪問済みのブロックを追跡するためのメカニズム（例: `visited`配列や`HashSet`）を追加する。
    *   探索で見つかったすべてのブロックに、計算された連結数を割り当てる。
3.  **Refactor (コードの改善)**
    *   BFS/DFSロジックを独立したプライベートヘルパー関数として抽出し、`calculate_connected_blocks`関数から呼び出すようにする。
    *   `visited`状態の管理を効率化する。

---

**サイクル 4: 表示色の設定**

1.  **Red (テストの追加)**
    *   **テストケース:** 連結数が設定されたブロックがある盤面を`calculate_connected_blocks`関数に渡した場合、そのブロックの`display_color`が元のブロックの色に、`text_color`が`Color::Black`に設定されていることを確認するテスト。
    *   **テストケース:** 連結数が設定されていないブロックの`display_color`と`text_color`が`None`のままであることを確認するテスト。
2.  **Green (最小限の実装)**
    *   連結数が設定されたブロックに対して、`display_color`をブロックの色に、`text_color`を`Color::Black`に設定するロジックを`calculate_connected_blocks`関数内に追加する。
3.  **Refactor (コードの改善)**
    *   色の設定ロジックを、`Cell`構造体のメソッドとしてカプセル化することを検討する。

---

**サイクル 5: 既存のゲームループへの統合**

1.  **Red (テストの追加)**
    *   **テストケース:** テトリミノが着地し、盤面が更新された直後に`calculate_connected_blocks`関数が呼び出され、盤面上の連結ブロックが正しく更新されていることを確認する統合テスト（またはシミュレーションテスト）。
2.  **Green (最小限の実装)**
    *   ゲームループ内のテトリミノ着地処理の直後に、`calculate_connected_blocks`関数を呼び出すコードを追加する。
3.  **Refactor (コードの改善)**
    *   ゲームループの構造を整理し、新しい関数呼び出しが自然に統合されるようにする。

3.  **Refactor (コードの改善)**
    *   実装したロジックを整理し、可読性、保守性、効率性を向上させる。
    *   連結判定ロジックを独立した関数として抽出し、再利用可能にする。
    *   `Cell`構造体のフィールド名やメソッド名を適切にリファクタリングする。
    *   既存の描画ロジックと統合し、数字表示が正しく行われるように調整する。